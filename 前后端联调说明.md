# 前后端联调说明

## 📋 概述

已完成小程序前端与后端服务的联调配置，实现了用户输入生辰信息后，调用后端接口获取AI分析结果并展示的完整流程。

## 🔧 修改内容

### 1. 首页 (`miniprogram/pages/index/index.js`)

**新增功能:**
- 添加了 `convertTimeToHour()` 方法,将中文时辰转换为小时数(0-23)
- 修改了 `handleSubmit()` 方法,将 hour 参数传递给 info 页面

**时辰映射表:**
```javascript
子时 → 23点  |  丑时 → 1点   |  寅时 → 3点   |  卯时 → 5点
辰时 → 7点   |  巳时 → 9点   |  午时 → 11点  |  未时 → 13点
申时 → 15点  |  酉时 → 17点  |  戌时 → 19点  |  亥时 → 21点
```

### 2. 信息展示页 (`miniprogram/pages/info/info.js`)

**核心改动:**
- 引入加密工具类 `crypto.js`
- 修改 `userInfo` 数据结构,使用 `hour` 替代 `time`
- 重写 `loadAnalysisData()` 方法,调用真实后端接口
- 新增 `formatAnalysisContent()` 方法,格式化后端返回的数据为展示文本
- 移除了模拟数据生成方法

**接口调用流程:**
1. 构造请求参数 (openId, gender, year, month, day, hour)
2. 生成时间戳和签名
3. 调用 `POST http://localhost:8080/api/bazi/analyze`
4. 解析返回数据并格式化展示

### 3. 加密工具类 (`miniprogram/utils/crypto.js`)

**功能说明:**
- 实现与后端 `SignatureUtil.java` 一致的签名算法
- 使用相同的签名密钥: `szbz-api-sign-key-2024`
- 签名流程:
  1. 将所有参数按 key 字母顺序排序
  2. 拼接为 `key1=value1&key2=value2&...&key=SIGN_KEY` 格式
  3. 对拼接字符串进行 MD5 加密
  4. 返回32位小写MD5值

## 📡 后端接口定义

### 接口地址
```
POST http://localhost:8080/api/bazi/analyze
```

### 请求头
```json
{
  "Content-Type": "application/json",
  "X-Timestamp": "1702800000000",
  "X-Sign": "生成的MD5签名"
}
```

### 请求体
```json
{
  "openId": "test_openid_1702800000000",
  "gender": "male",
  "year": 2014,
  "month": 6,
  "day": 15,
  "hour": 11
}
```

### 响应示例
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "baziResult": {
      "fourPillars": {
        "year": { "tianGan": "甲", "diZhi": "午" },
        "month": { "tianGan": "庚", "diZhi": "午" },
        "day": { "tianGan": "戊", "diZhi": "申" },
        "hour": { "tianGan": "壬", "diZhi": "午" }
      }
    },
    "aiAnalysis": "AI生成的分析文本内容..."
  },
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "timestamp": 1702800000000
}
```

## 🧪 测试步骤

### 前置准备

1. **启动后端服务**
```bash
cd D:\project\szbz
mvn spring-boot:run
```

2. **验证后端服务**
打开浏览器访问: `http://localhost:8080`

3. **配置小程序开发工具**
   - 打开微信开发者工具
   - 导入项目: `d:\project\szbzMiniApp`
   - 在设置中勾选 "不校验合法域名、web-view、TLS版本及HTTPS证书"

### 测试流程

1. **在首页填写信息**
   - 选择性别: 男/女
   - 选择出生年月日
   - 选择时辰

2. **点击提交按钮**
   - 小程序会跳转到 info 页面
   - 自动显示 "正在分析中..." 加载状态

3. **观察控制台日志**
   - 查看请求参数、时间戳、签名
   - 查看接口返回数据

4. **查看分析结果**
   - 成功: 展示格式化后的八字和AI分析内容
   - 失败: 显示错误提示,可点击"重新加载"

### 测试用例

#### 用例1: 正常流程
- **输入**: 男,2014年6月15日午时
- **期望**: 正常显示八字和AI分析结果

#### 用例2: 后端未启动
- **场景**: 关闭后端服务
- **期望**: 显示 "网络请求失败,请检查后端服务是否启动"

#### 用例3: 签名验证失败
- **场景**: 修改 `crypto.js` 中的 `SIGN_KEY`
- **期望**: 后端返回 "签名验证失败"

## 🔍 调试技巧

### 查看请求详情
在 `info.js` 的 `loadAnalysisData()` 方法中已添加详细日志:
```javascript
console.log('请求参数:', requestData)
console.log('时间戳:', timestamp)
console.log('签名:', sign)
console.log('接口返回:', res)
```

### 验证签名算法
可以在后端添加日志对比前后端生成的签名:
```java
// BaZiController.java analyzeBaZiWithAI() 方法中
String expectedSign = signatureUtil.generateSignature(params, timestamp);
System.out.println("前端签名: " + sign);
System.out.println("后端签名: " + expectedSign);
```

### 常见问题排查

1. **签名验证失败**
   - 检查前后端 `SIGN_KEY` 是否一致
   - 检查参数排序是否正确
   - 检查 MD5 算法实现是否一致

2. **时间戳过期**
   - 后端限制时间戳在2秒内有效
   - 确保前后端服务器时间同步

3. **跨域问题**
   - 小程序开发工具需要关闭域名校验
   - 后端需要配置 CORS (已在项目中配置)

## 📝 数据展示格式

展示页面会将后端返回数据格式化为:

```
【基本信息】
性别：男
出生时间：2014年6月15日 11时

【生辰八字】
年柱：甲午
月柱：庚午
日柱：戊申
时柱：壬午

【AI智能分析】
(后端Gemini API返回的分析内容)
```

## 🚀 后续优化建议

1. **获取真实 openId**
   - 使用 `wx.login()` 和 `wx.getUserProfile()` 获取用户真实信息
   - 需要配置微信小程序 AppID 和 AppSecret

2. **错误处理优化**
   - 添加网络重试机制
   - 区分不同错误类型显示友好提示

3. **性能优化**
   - 添加请求防抖/节流
   - 实现本地缓存减少重复请求

4. **安全加固**
   - 将签名密钥移到服务端,前端仅传输时间戳
   - 实现更复杂的加密算法(如 HMAC-SHA256)

## ✅ 验收标准

- [x] 首页正确传递 hour 参数
- [x] info 页面成功调用后端接口
- [x] 签名算法与后端一致
- [x] 正确解析和展示后端返回数据
- [x] 错误情况有友好提示
- [x] 支持重新加载功能

---

**开发完成日期:** 2025-12-17  
**开发人员:** AI智能编程助手
